************************************************************************
* header:                 COMMANDS (simple)
*  These modules deal with simple commands that affect maps and phase
*  space data.  Ray trace related commands are found in TRAC, and input
*  output related commands are found in INPU.
*
* Rob Ryne 7/28/2002
* This file was generated by taking comm.f from the 5th order version
* that Tom Mottershead and I were using and including the following
* from the ML30dev version:
* cmom, cmom5, dpol, tpol
* also, wnda and wnd were added to replace swnd and dwnd 
* Note that, in cmom5 (which is not used), monoms5 has been replaced by monom
* Note also that evalm and evalm5 (not used) have been added to liea.f
************************************************************************
cryne 5/3/2006 this version (comm1) omits anything involving zblock
************************************************************************
c
c
      subroutine dpol(p,fa,fm)
c This is a subroutine for setting up a quadratic polynomial
c described in terms of dispersion parameters.
c Written by Alex Dragt, 29 March 1991
c
      use lieaparam, only : monoms
      include 'impli.inc'
c
      dimension fa(monoms)
      dimension fm(6,6)
      dimension p(6)
c
c set map to the identity
      call ident(fa,fm)
c
c set up polynomial
      fa(12)=p(2)
      fa(17)=-p(1)
      fa(21)=p(4)
      fa(24)=-p(3)
      fa(27)=-p(5)/2.d0
c
      return
      end
c
***********************************************************************
c
      subroutine ident(h,xmh)
c Written by D. Douglas, ca 1982
      use lieaparam, only : monoms
      include 'impli.inc'
      dimension h(monoms),xmh(6,6)
      do 10 i=1,6
      do 10 j=1,6
   10 xmh(i,j)=0.
      do 15 i=1,6
   15 xmh(i,i)=1.
      do 20 i=1,monoms
   20 h(i)=0.
c
      return
      end
c
***********************************************************************
c
      subroutine inv(ha,hm)
c  Returns the inverse of the map represented by ha,hm
c  based on the reverse to Marylie order factorization
c  routine cfacrm.  Written 2/2/96 AJD
c
      include 'impli.inc'
c
c----Variables----
c
      dimension ha(*),hm(6,6)
c
c----Routine----
c
c  Invert matrix part of map.
      call minv(hm)
c  Reverse sign of polynomials:
      do 100 ind=1,923
  100   ha(ind)=-ha(ind)
c Now reverse order:
      call cfacrm(ha,hm)
c
      return
      end
c
*********************************************************************
c
      subroutine mask6(wipe,h,mh)
c
c  Sets higher order monomial coefficients to zero as specified by wipe
c  Written by Liam Healy, Spring 1985
c
c     implicit none
c  Variables
c  wipe = array of flags: if nth element is less than 0.5, nth order is
c         set to the identity map
      double precision wipe(*)
c  h, mh = polynomial and matrix (input and output)
      double precision h(*),mh(6,6)
c  ord = order of polynomial
      integer ord
c
      include 'maxcat.inc'
      include 'lims.inc'
c
c----Routine----
      if (wipe(1).le.0.5) then
        do 100 i=1,6
          do 100 j=1,6
  100       mh(i,j)=0.
        do 120 i=1,6
  120     mh(i,i)=1.
      endif
      do 200 ord=2,ordcat
        if (wipe(ord).le.0.5) then
          do 140 i=bottom(ord),top(ord)
  140       h(i)=0.
        endif
  200 continue
      return
      end
c
*********************************************************************
c
      subroutine mask(akeep,ha,hm)
c
c  Keeps or removes portions of the map as specified by akeep.
c  Written by A. Dragt 2/3/96 to work thru f6.
c
      include 'impli.inc'
      include 'maxcat.inc'
      include 'lims.inc'
c
cryne 12/31/2004:
      integer keep
c
c  Variables
c
c  akeep = array of flags: 
      dimension akeep(*)
c  ha, hm = polynomial and matrix (input and output)
      dimension ha(*),hm(6,6)
c  keep = integer version of akeep
      dimension keep(6)
c
c----Routine----
c
c set up keep
      do 10 i=1,6
   10 keep(i) = nint(akeep(i))
c
c mask the map order by order
c
c f1 contents:
      if (keep(1) .eq. 0) then
      do 100 i=1,6
  100 ha(i) = 0.d0
      endif
c f2 and matrix contents:
      if (keep(2) .eq. 0) then
      do 200 i=7,27
  200 ha(i) = 0.d0
      call mident(hm)
      endif
c f3 contents:
      if (keep(3) .eq. 0) then
      do 300 i=28,83
  300 ha(i) = 0.d0
      endif
c f4 contents:
      if (keep(4) .eq. 0) then
      do 400 i=84,209
  400 ha(i) = 0.d0
      endif
c f5 contents:
      if (keep(5) .eq. 0) then
      do 500 i=210,461
  500 ha(i) = 0.d0
      endif
c f6 contents:
      if (keep(6) .eq. 0) then
      do 600 i=462,923
  600 ha(i) = 0.d0
      endif
c
      return
      end
c
***********************************************************************
c
      subroutine mtran(mh)
c  Takes the transpose of the matrix mh.
c  Written by Liam Healy, April 16, 1985.
c     implicit none
      double precision mh(6,6),hold
      integer i,j
c
c----Routine----
      do 100 i=1,6
        do 100 j=1,i-1
          hold=mh(j,i)
          mh(j,i)=mh(i,j)
          mh(i,j)=hold
  100 continue
      return
      end
c
***********************************************************************
c
      subroutine rev(h,mh)
c This is a subroutine for reversing a map.
c Written by Alex Dragt on Friday, 13 Sept 1985.
      use lieaparam, only : monoms
c     implicit none
      include 'expon.inc'
c
      double precision h(*),mh(6,6)
      double precision temp(6,6)
      double precision r(6,6)
c Define the reversing matrix r by a set of data statements:
      data (r(1,j),j=1,6)/ 1.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0/
      data (r(2,j),j=1,6)/ 0.d0,-1.d0, 0.d0, 0.d0, 0.d0, 0.d0/
      data (r(3,j),j=1,6)/ 0.d0, 0.d0, 1.d0, 0.d0, 0.d0, 0.d0/
      data (r(4,j),j=1,6)/ 0.d0, 0.d0, 0.d0,-1.d0, 0.d0, 0.d0/
      data (r(5,j),j=1,6)/ 0.d0, 0.d0, 0.d0, 0.d0,-1.d0, 0.d0/
      data (r(6,j),j=1,6)/ 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.d0/
      save r
c----Routine----
c Compute inverse map:
      call inv(h,mh)
c Reverse matrix portion of map:
      call mmult (r,mh,temp)
      call mmult (temp,r,mh)
c Reverse polynomial portion of map:
c For now, work only with n in the interval [28,209].
c Change range of n later when f1's are implemented.
      do 10 n=28,209
        n2 = expon(2,n)
        n4 = expon(4,n)
        n5 = expon(5,n)
        m = n2+n4+n5
        mm2 = mod(m,2)
        if (mm2.eq.0) h(n)=-h(n)
   10 continue
      return
      end
c
***********************************************************************
c
      subroutine revf(iord,ha,hm)
c  Changes the order of factorization.
c  If iord=0, it is assumed that the map specified by ha,hm is in the
c  standard MARYLIE order exp(:f2:)exp(:f3:)exp(:f4)....  This
c  routine will then return g3,g4... corresponding to the factorization
c  ...exp(:g4:)exp(:g3:)exp(:f2:).
c  If iord=1, it is assumed that the map specified by ha,hm is in
c  reversed order.  This routine then returns the standard
c  MARYLIE order.  Written by Alex Dragt 1/31/96
c
      include 'impli.inc'
c
c----Variables----
c
      dimension ha(*),hm(6,6)
c
c----Routine----
c
      if(iord.gt.0) then
c
c----Procedure for going from reversed order to MARYLIE order:
c
      call cfacrm(ha,hm)
c
      else
c
c----Procedure for going from MARYLIE order to reversed order:
c
      call cfacmr(ha,hm)
c
      endif
c
      return
      end
c
***********************************************************************
c
      subroutine cfacmr(ha,hm)
c  Changes the order of factorization from Marylie to reversed order
c  using the inversion routine.
c  Written by Alex Dragt 1/31/96
c
c----Variables----
c
      include 'impli.inc'
c
      dimension ha(*),hm(6,6)
      dimension ha1(923),hm1(6,6)
      dimension ha2(923),hm2(6,6)
c
c----Routine----
c
c----Procedure for going from MARYLIE order to reversed order:
c
c  Clear ha1,hm1
      call clear(ha1,hm1)
c  Copy hm into hm1
      call matmat(hm,hm1)
c  Invert the map ha,hm
      call inv(ha,hm)
c  Concatenate with the map ha1,hm1
      call concat(ha1,hm1,ha,hm,ha2,hm2)
c  Change signs of monomials
      do 120 ind=1,923
  120   ha(ind)=-ha2(ind)
c  Replace current hm with its original version, hm1
      call matmat(hm1,hm)
c
      return
      end
c
***********************************************************************
c
      subroutine cfacrm(ha,hm)
c  Changes the order of factorization from reversed to
c  Marylie order using the concatenator.
c  Written by Alex Dragt 1/31/96
c
c----Variables----
c
      include 'impli.inc'
c
      dimension ha(923),hm(6,6)
      dimension ha1(923),hm1(6,6)
      dimension ha2(923),hm2(6,6)
      dimension ha3(923),hm3(6,6)
      dimension akeep(6)
c
c----Routine----
c
c----Procedure for going from reversed order to MARYLIE order:
c--- This should work thru 6th order (AJD)
c
c get only matrix part
      call mapmap(ha,hm,ha1,hm1)
      akeep(1)=0.
      akeep(2)=1.d0
      akeep(3)=0.
      akeep(4)=0.
      akeep(5)=0.
      akeep(6)=0.
      call mask(akeep,ha1,hm1)
c get only g3 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=1.d0
      akeep(4)=0.
      akeep(5)=0.
      akeep(6)=0.
      call mask(akeep,ha2,hm2)
c concatenate exp(:g3:)exp(:g2:)
      call concat(ha2,hm2,ha1,hm1,ha3,hm3)
c store result in ha1,hm1
      call mapmap(ha3,hm3,ha1,hm1)
c get only g4 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=0.
      akeep(4)=1.d0
      akeep(5)=0.
      akeep(6)=0.
      call mask(akeep,ha2,hm2)
c concatenate exp(:g4:)exp(:g3:)exp(:g2:)
      call concat(ha2,hm2,ha1,hm1,ha3,hm3)
c store result in ha1,hm1
      call mapmap(ha3,hm3,ha1,hm1)
c      write(6,*) 'result after g4'
c      call pcmap(1,1,0,0,ha1,hm1)
c get only g5 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=0.
      akeep(4)=0.
      akeep(5)=1.d0
      akeep(6)=0.
      call mask(akeep,ha2,hm2)
c      write(6,*) 'first factor'
c      call pcmap(1,1,0,0,ha2,hm2)
c      write(6,*) 'second factor'
c      call pcmap(1,1,0,0,ha1,hm1)
c concatenate exp(:g5:)exp(:g4:)exp(:g3:)exp(:g2:)
      call concat(ha2,hm2,ha1,hm1,ha3,hm3)
c      write(6,*) 'result after concat'
c      call pcmap(1,1,0,0,ha3,hm3)
c store result in ha1,hm1
      call mapmap(ha3,hm3,ha1,hm1)
c      write(6,*) 'result after g5 mapmap'
c      call pcmap(1,1,0,0,ha1,hm1)
c get only g6 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=0.
      akeep(4)=0.
      akeep(5)=0.
      akeep(6)=1.d0
      call mask(akeep,ha2,hm2)
c      write(6,*) 'result after g6 mask'
c      call pcmap(1,1,0,0,ha2,hm2)
c concatenate exp(:g6:)exp(:g5:)exp(:g4:)exp(:g3:)exp(:g2:) 
c and put result in ha,hm.
      call concat(ha2,hm2,ha1,hm1,ha,hm)
c
      end
c
***********************************************************************
c
      subroutine strget(kynd,nmap,fa,fm)
cryne 12/15/2004 modified to use new common block structure of stmap.inc
c
c This is a subroutine for storing and getting maps.
c A total of 5 maps can be stored and retrieved.
c The incoming and outgoing maps are represented by fa,fm.
c In the store mode, the maps are stored in sf1,sm1 to sf5,sm5.
c In the retrieve mode, the map is gotten from sf1,sm1 to sf5,sm5.
c The maps sf1,sm1 to sf5,sm5 are stored in the block common stmap.
c Written by Alex Dragt, Spring 1987. Modified 10/13/88 AJD.
c
      use lieaparam, only : monoms
      include 'impli.inc'
      include 'files.inc'
      include 'stmap.inc'
      character*3 kynd
c
c Calling arrays
      dimension fa(monoms),fm(6,6)
c
c
cryne fix later so that "20" is not hardwired
      if(nmap.gt.20)then
        if(idproc.eq.0)write(6,*)'ERROR: too many stored maps'
        if(idproc.eq.0)write(6,*)'nmap=',nmap
        call myexit
      endif
c
      if (kynd.eq.'gtm') goto 100
c Procedure for storing maps:
      write(jof,400) nmap
  400 format(1x,'map stored in location',2x,i2)
!     goto(10,20,30,40,50),nmap
!  10 call mapmap(fa,fm,sf1,sm1)
!     return
!  20 call mapmap(fa,fm,sf2,sm2)
!     return
!  30 call mapmap(fa,fm,sf3,sm3)
!     return
!  40 call mapmap(fa,fm,sf4,sm4)
!     return
!  50 call mapmap(fa,fm,sf5,sm5)
      call mapmap(fa,fm,storedpoly(1,nmap),storedmat(1,1,nmap))
      return
c
c Procedure for getting maps:
  100 continue
!!!!!      write(jof,450) nmap
!!!!!  450 format(1x,'map gotten from location',2x,i2)
!     goto(110,120,130,140,150),nmap
! 110 call mapmap(sf1,sm1,fa,fm)
!     return
! 120 call mapmap(sf2,sm2,fa,fm)
!     return
! 130 call mapmap(sf3,sm3,fa,fm)
!     return
! 140 call mapmap(sf4,sm4,fa,fm)
!     return
! 150 call mapmap(sf5,sm5,fa,fm)
      call mapmap(storedpoly(1,nmap),storedmat(1,1,nmap),fa,fm)
c
      return
      end
c
*********************************************************************
c
      subroutine sympl(itype,fa,fm)
c  This is a symplectification subroutine
c Written by Alex Dragt, Spring 1987.
      use lieaparam, only : monoms
      include 'impli.inc'
      dimension fa(monoms),fm(6,6)
c
      if (itype.eq.1) call sympl1(fm)
      if (itype.eq.2) call sympl2(fm)
      if (itype.eq.3) call sympl3(fm)
c
      return
      end
c
*********************************************************************
c
      subroutine tpol(p,fa,fm)
c This is a subroutine for computing a quadratic polynomial
c described in terms of twiss parameters.
c Written by Alex Dragt, 21 December 1990
      use lieaparam
      include 'impli.inc'
cryne 5/3/2006      include 'param.inc'
      dimension p(6)
      dimension fa(monoms),fm(6,6)
c-----
c set map to the identity
      call ident(fa,fm)
c set up twiss parameters
      ax=p(1)
      bx=p(2)
      ay=p(3)
      by=p(4)
      at=p(5)
      bt=p(6)
      if(bx .gt. 0.d0) gx=(1.+ax*ax)/bx
      if(by .gt. 0.d0) gy=(1.+ay*ay)/by
      if(bt .gt. 0.d0) gt=(1.+at*at)/bt
      if (bx .le. 0.) then
      ax=0.
      bx=0.
      gx=0.
      endif
      if (by .le. 0.) then
      ay=0.
      by=0.
      gy=0.
      endif
      if (bt .le. 0.) then
      at=0.
      bt=0.
      gt=0.
      endif
c set up polynomial
      fa(7)=gx
      fa(8)=2.d0*ax
      fa(13)=bx
      fa(18)=gy
      fa(19)=2.d0*ay
      fa(22)=by
      fa(25)=gt
      fa(26)=2.d0*at
      fa(27)=bt
      return
      end
c
*********************************************************************
c
c end of file
